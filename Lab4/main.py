import numpy as npimport matplotlib.pyplot as pltimport funkcjePomocniczeimport scipy.integrate as spintif __name__ == '__main__':    # Preprocessing    # Parametry sterujace    c = 0    def f(x): return 1  # wymuszenie    # 2.Geometria    # 2.1 Definicja    # Automatyczne wygenerowanie geometrii    x_a = 0    x_b = 1    n = 5    WEZLY, ELEMENTY = funkcjePomocnicze.AutomatycznyGeneratorGeometrii(        x_a, x_b, n)    WB = [{"ind": 1, "typ": 'D', "wartosc": 1},          {"ind": n, "typ": 'D', "wartosc": 2}]    # Processing    A, b = funkcjePomocnicze.Alokacja(n)    stopFunB = 1    phi, dphi = funkcjePomocnicze.FunkcjeBazowe(stopFunB)    xx = np.linspace(-1, 1, 202)    plt.plot(xx, phi[0](xx), 'r')    plt.plot(xx, phi[1](xx), 'g')    plt.plot(xx, dphi[0](xx), 'b')    plt.plot(xx, dphi[1](xx), 'c')    for ee in np.arange(0, np.shape(ELEMENTY)[0]):        elemWezel1 = ELEMENTY[ee, 1]        elemWezel2 = ELEMENTY[ee, 2]        indGlobalneWezlow = np.array([elemWezel1, elemWezel2])        x_a = WEZLY[elemWezel1-1, 1]        x_b = WEZLY[elemWezel2-1, 1]        J = (x_b-x_a)/2        Ml = np.zeros([stopFunB+1, stopFunB+1])        n = 0        m = 0        Ml[n, m] = J * spint.quad(funkcjePomocnicze.Aij(dphi[n],                                                        dphi[m], c, phi[n], phi[m]), -1, 1)[0]        n = 0        m = 1        Ml[n, m] = J * spint.quad(funkcjePomocnicze.Aij(dphi[n],                                                        dphi[m], c, phi[n], phi[m]), -1, 1)[0]        n = 1        m = 0        Ml[n, m] = J * spint.quad(funkcjePomocnicze.Aij(dphi[n],                                                        dphi[m], c, phi[n], phi[m]), -1, 1)[0]        n = 1        m = 1        Ml[n, m] = J * spint.quad(funkcjePomocnicze.Aij(dphi[n],                                                        dphi[m], c, phi[n], phi[m]), -1, 1)[0]        A[np.ix_(indGlobalneWezlow-1, indGlobalneWezlow-1)          ] = A[np.ix_(indGlobalneWezlow-1, indGlobalneWezlow-1)] + Ml    # UWZGLEDNIENIE WARUNKOW BRZEGOWYCH    if WB[0]['typ'] == 'D':        indWezla = WB[0]['ind']        wartWarBrzeg = WB[0]['wartosc']        iwp = indWezla - 1        WZMACNIACZ = 10**14        b[iwp] = A[iwp, iwp]*WZMACNIACZ*wartWarBrzeg        A[iwp, iwp] = A[iwp, iwp]*WZMACNIACZ    if WB[1]['typ'] == 'D':        indWezla = WB[1]['ind']        wartWarBrzeg = WB[1]['wartosc']        iwp = indWezla - 1        WZMACNIACZ = 10**14        b[iwp] = A[iwp, iwp]*WZMACNIACZ*wartWarBrzeg        A[iwp, iwp] = A[iwp, iwp]*WZMACNIACZ    if WB[0]['typ'] == 'N':        print('Nie zaimplementowano')    if WB[1]['typ'] == 'N':        print('Nie zaimplementowano')    # Rozwiazanie ukladow rownan liniowych    u = np.linalg.solve(A, b)    funkcjePomocnicze.RysujRozwiazanie(WEZLY, ELEMENTY, WB, u)