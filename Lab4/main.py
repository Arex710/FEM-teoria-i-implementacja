import numpy as npimport matplotlib.pyplot as pltimport Lab4import scipy.integrate as spintif __name__ == '__main__':    # Preprocessing    # Parametry sterujace    c = 0    f = lambda x: 1 # wymuszenie    # 2.Geometria    # 2.1 Definicja    # WEZLY, ELEMENTY, WB = GeometriaDefinicja()    ## Automatyczne wygenerowanie geometrii    x_a = 0    x_b = 1    n = 5    WEZLY, ELEMENTY = Lab4.AutomatycznyGeneratorGeometrii(x_a,x_b,n)    WB = [{"ind": 1, "typ":'D', "wartosc":1},          {"ind": n, "typ":'D', "wartosc":2}]    #Lab4.RysujGeometrie(WEZLY, ELEMENTY, WB)    print(WEZLY)    print(ELEMENTY)    #Processing    [A, b] = Lab4.Alokacja(n)    stop_fun_b = 1    phi, dphi = Lab4.FunkcjeBazowe(1)    xx = np.linspace(-1, 1, 101)    plt.plot(xx, phi[0](xx), 'r')    plt.plot(xx, phi[1](xx), 'g')    plt.plot(xx, dphi[0](xx), 'b')    plt.plot(xx, dphi[1](xx), 'c')    plt.show()    liczbaElementow = np.shape(ELEMENTY)[0]    for ee in np.arange[0, liczbaElementow]:                elemIndRow = ee        elemGlobalInd = ELEMENTY[ee,0]        elemWezel1 = ELEMENTY[ee,1]        elemWezel2 = ELEMENTY[ee,2]        a = WEZLY[elemWezel1-1 ,1]        b = WEZLY[elemWezel2-1 ,1]        J = (b-a)/2        Ml = np.zeros([stop_fun_b+1], stop_fun_b+1)        n = 0; m = 0;        Ml[n,m] = J * spint.quad(Aij(dphi[n], dphi[m], c , phi[n], phi[m]), -1, 1)        n = 0; m = 1;        Ml[n,m] = J * spint.quad(Aij(dphi[n], dphi[m], c , phi[n], phi[m]), -1, 1)        n = 1; m = 0;        Ml[n,m] = J * spint.quad(Aij(dphi[n], dphi[m], c , phi[n], phi[m]), -1, 1)        n = 1; m = 1;        Ml[n,m] = J * spint.quad(Aij(dphi[n], dphi[m], c , phi[n], phi[m]), -1, 1)